"""WPScan API integration for WordPress vulnerability scanning"""

import requests
from typing import Dict, List, Optional
from datetime import datetime, timedelta, timezone
import json
import time


class VulnerabilityScanner:
    """WordPress vulnerability scanner using WPScan API"""

    WPSCAN_API_URL = "https://wpscan.com/api/v3"
    CACHE_DURATION = 3600  # 1 hour in seconds
    RATE_LIMIT_DELAY = 1  # Delay between requests in seconds

    def __init__(self, api_token: Optional[str] = None):
        """
        Initialize vulnerability scanner

        Args:
            api_token: WPScan API token (optional)
        """
        self.api_token = api_token
        self._cache = {}
        self._last_request_time = 0
        self._request_count = 0

    def set_api_token(self, token: str):
        """Set WPScan API token"""
        self.api_token = token

    def scan_plugin(self, plugin_slug: str, version: Optional[str] = None) -> Dict:
        """
        Scan plugin for vulnerabilities

        Args:
            plugin_slug: WordPress plugin slug
            version: Plugin version (optional)

        Returns:
            Dictionary with vulnerability information
        """
        if not self.api_token:
            return {
                'slug': plugin_slug,
                'version': version,
                'vulnerabilities': [],
                'error': 'No API token configured'
            }

        # Check cache
        cache_key = f"plugin:{plugin_slug}:{version or 'latest'}"
        if cache_key in self._cache:
            cached_data, cached_time = self._cache[cache_key]
            if (datetime.now(timezone.utc) - cached_time).total_seconds() < self.CACHE_DURATION:
                return cached_data

        # Rate limiting
        self._apply_rate_limit()

        # Make API request
        url = f"{self.WPSCAN_API_URL}/plugins/{plugin_slug}"
        headers = {"Authorization": f"Token token={self.api_token}"}

        try:
            response = requests.get(url, headers=headers, timeout=10)
            self._request_count += 1

            if response.status_code == 200:
                data = response.json()
                result = self._parse_plugin_response(data, plugin_slug, version)

                # Cache result
                self._cache[cache_key] = (result, datetime.now(timezone.utc))

                return result

            elif response.status_code == 404:
                return {
                    'slug': plugin_slug,
                    'version': version,
                    'vulnerabilities': [],
                    'not_found': True
                }

            elif response.status_code == 429:
                return {
                    'slug': plugin_slug,
                    'version': version,
                    'vulnerabilities': [],
                    'error': 'API rate limit exceeded'
                }

            else:
                return {
                    'slug': plugin_slug,
                    'version': version,
                    'vulnerabilities': [],
                    'error': f'API error: {response.status_code}'
                }

        except requests.exceptions.RequestException as e:
            return {
                'slug': plugin_slug,
                'version': version,
                'vulnerabilities': [],
                'error': f'Request failed: {str(e)}'
            }
        except Exception as e:
            return {
                'slug': plugin_slug,
                'version': version,
                'vulnerabilities': [],
                'error': f'Unexpected error: {str(e)}'
            }

    def scan_theme(self, theme_slug: str, version: Optional[str] = None) -> Dict:
        """
        Scan theme for vulnerabilities

        Args:
            theme_slug: WordPress theme slug
            version: Theme version (optional)

        Returns:
            Dictionary with vulnerability information
        """
        if not self.api_token:
            return {
                'slug': theme_slug,
                'version': version,
                'vulnerabilities': [],
                'error': 'No API token configured'
            }

        # Check cache
        cache_key = f"theme:{theme_slug}:{version or 'latest'}"
        if cache_key in self._cache:
            cached_data, cached_time = self._cache[cache_key]
            if (datetime.now(timezone.utc) - cached_time).total_seconds() < self.CACHE_DURATION:
                return cached_data

        # Rate limiting
        self._apply_rate_limit()

        # Make API request
        url = f"{self.WPSCAN_API_URL}/themes/{theme_slug}"
        headers = {"Authorization": f"Token token={self.api_token}"}

        try:
            response = requests.get(url, headers=headers, timeout=10)
            self._request_count += 1

            if response.status_code == 200:
                data = response.json()
                result = self._parse_theme_response(data, theme_slug, version)

                # Cache result
                self._cache[cache_key] = (result, datetime.now(timezone.utc))

                return result

            elif response.status_code == 404:
                return {
                    'slug': theme_slug,
                    'version': version,
                    'vulnerabilities': [],
                    'not_found': True
                }

            elif response.status_code == 429:
                return {
                    'slug': theme_slug,
                    'version': version,
                    'vulnerabilities': [],
                    'error': 'API rate limit exceeded'
                }

            else:
                return {
                    'slug': theme_slug,
                    'version': version,
                    'vulnerabilities': [],
                    'error': f'API error: {response.status_code}'
                }

        except requests.exceptions.RequestException as e:
            return {
                'slug': theme_slug,
                'version': version,
                'vulnerabilities': [],
                'error': f'Request failed: {str(e)}'
            }
        except Exception as e:
            return {
                'slug': theme_slug,
                'version': version,
                'vulnerabilities': [],
                'error': f'Unexpected error: {str(e)}'
            }

    def scan_wordpress_core(self, version: str) -> Dict:
        """
        Scan WordPress core version for vulnerabilities

        Args:
            version: WordPress core version

        Returns:
            Dictionary with vulnerability information
        """
        if not self.api_token:
            return {
                'version': version,
                'vulnerabilities': [],
                'error': 'No API token configured'
            }

        # Check cache
        cache_key = f"core:{version}"
        if cache_key in self._cache:
            cached_data, cached_time = self._cache[cache_key]
            if (datetime.now(timezone.utc) - cached_time).total_seconds() < self.CACHE_DURATION:
                return cached_data

        # Rate limiting
        self._apply_rate_limit()

        # Make API request
        url = f"{self.WPSCAN_API_URL}/wordpresses/{version}"
        headers = {"Authorization": f"Token token={self.api_token}"}

        try:
            response = requests.get(url, headers=headers, timeout=10)
            self._request_count += 1

            if response.status_code == 200:
                data = response.json()
                result = self._parse_core_response(data, version)

                # Cache result
                self._cache[cache_key] = (result, datetime.now(timezone.utc))

                return result

            elif response.status_code == 404:
                return {
                    'version': version,
                    'vulnerabilities': [],
                    'not_found': True
                }

            elif response.status_code == 429:
                return {
                    'version': version,
                    'vulnerabilities': [],
                    'error': 'API rate limit exceeded'
                }

            else:
                return {
                    'version': version,
                    'vulnerabilities': [],
                    'error': f'API error: {response.status_code}'
                }

        except requests.exceptions.RequestException as e:
            return {
                'version': version,
                'vulnerabilities': [],
                'error': f'Request failed: {str(e)}'
            }
        except Exception as e:
            return {
                'version': version,
                'vulnerabilities': [],
                'error': f'Unexpected error: {str(e)}'
            }

    def _parse_plugin_response(self, data: Dict, slug: str, version: Optional[str]) -> Dict:
        """Parse WPScan API plugin response"""
        vulnerabilities = []

        plugin_data = data.get(slug, {})
        vuln_list = plugin_data.get('vulnerabilities', [])

        for vuln in vuln_list:
            # Check if vulnerability affects the current version
            if version:
                fixed_in = vuln.get('fixed_in')
                if fixed_in and self._version_compare(version, fixed_in) >= 0:
                    continue  # Version is fixed

            vulnerability = {
                'title': vuln.get('title', 'Unknown vulnerability'),
                'type': vuln.get('vuln_type', 'Unknown'),
                'fixed_in': vuln.get('fixed_in'),
                'references': vuln.get('references', {}).get('url', []),
                'cvss': vuln.get('cvss', {}).get('score'),
            }

            vulnerabilities.append(vulnerability)

        return {
            'slug': slug,
            'version': version,
            'vulnerabilities': vulnerabilities,
            'latest_version': plugin_data.get('latest_version'),
            'popular': plugin_data.get('popular', False)
        }

    def _parse_theme_response(self, data: Dict, slug: str, version: Optional[str]) -> Dict:
        """Parse WPScan API theme response"""
        vulnerabilities = []

        theme_data = data.get(slug, {})
        vuln_list = theme_data.get('vulnerabilities', [])

        for vuln in vuln_list:
            # Check if vulnerability affects the current version
            if version:
                fixed_in = vuln.get('fixed_in')
                if fixed_in and self._version_compare(version, fixed_in) >= 0:
                    continue  # Version is fixed

            vulnerability = {
                'title': vuln.get('title', 'Unknown vulnerability'),
                'type': vuln.get('vuln_type', 'Unknown'),
                'fixed_in': vuln.get('fixed_in'),
                'references': vuln.get('references', {}).get('url', []),
                'cvss': vuln.get('cvss', {}).get('score'),
            }

            vulnerabilities.append(vulnerability)

        return {
            'slug': slug,
            'version': version,
            'vulnerabilities': vulnerabilities,
            'latest_version': theme_data.get('latest_version')
        }

    def _parse_core_response(self, data: Dict, version: str) -> Dict:
        """Parse WPScan API WordPress core response"""
        vulnerabilities = []

        core_data = data.get(version, {})
        vuln_list = core_data.get('vulnerabilities', [])

        for vuln in vuln_list:
            vulnerability = {
                'title': vuln.get('title', 'Unknown vulnerability'),
                'type': vuln.get('vuln_type', 'Unknown'),
                'fixed_in': vuln.get('fixed_in'),
                'references': vuln.get('references', {}).get('url', []),
                'cvss': vuln.get('cvss', {}).get('score'),
            }

            vulnerabilities.append(vulnerability)

        return {
            'version': version,
            'vulnerabilities': vulnerabilities
        }

    def convert_to_findings(self, scan_result: Dict, site_name: str, component_type: str) -> List[Dict]:
        """
        Convert vulnerability scan results to standard finding format

        Args:
            scan_result: Scan result from WPScan API
            site_name: Site name
            component_type: Type of component (core, plugin, theme)

        Returns:
            List of findings
        """
        findings = []

        if 'error' in scan_result:
            # Don't create findings for errors
            return findings

        slug = scan_result.get('slug', scan_result.get('version', 'unknown'))
        version = scan_result.get('version', 'unknown')

        for idx, vuln in enumerate(scan_result.get('vulnerabilities', [])):
            # Determine severity from CVSS score
            cvss = vuln.get('cvss')
            if cvss:
                if cvss >= 9.0:
                    severity = 'critical'
                elif cvss >= 7.0:
                    severity = 'high'
                elif cvss >= 4.0:
                    severity = 'medium'
                else:
                    severity = 'low'
            else:
                severity = 'high'  # Default to high if no CVSS

            # Build finding
            finding = {
                'id': f'VULN-{site_name}-{component_type.upper()}-{slug}-{idx+1}',
                'severity': severity,
                'title': f'{component_type.capitalize()} vulnerability: {slug}',
                'description': vuln.get('title', 'Unknown vulnerability'),
                'impact': f'Vulnerable {component_type} may be exploited',
                'remediation': f"Update {slug} to version {vuln.get('fixed_in', 'latest')}",
                'auto_fix': None,
                'cvss': cvss,
                'references': vuln.get('references', [])
            }

            findings.append(finding)

        return findings

    def _apply_rate_limit(self):
        """Apply rate limiting between requests"""
        current_time = time.time()
        time_since_last = current_time - self._last_request_time

        if time_since_last < self.RATE_LIMIT_DELAY:
            time.sleep(self.RATE_LIMIT_DELAY - time_since_last)

        self._last_request_time = time.time()

    def _version_compare(self, version1: str, version2: str) -> int:
        """
        Compare two version strings

        Args:
            version1: First version
            version2: Second version

        Returns:
            -1 if version1 < version2, 0 if equal, 1 if version1 > version2
        """
        def normalize(v):
            return [int(x) for x in v.split('.') if x.isdigit()]

        v1_parts = normalize(version1)
        v2_parts = normalize(version2)

        # Pad with zeros
        max_len = max(len(v1_parts), len(v2_parts))
        v1_parts += [0] * (max_len - len(v1_parts))
        v2_parts += [0] * (max_len - len(v2_parts))

        for i in range(max_len):
            if v1_parts[i] < v2_parts[i]:
                return -1
            elif v1_parts[i] > v2_parts[i]:
                return 1

        return 0

    def get_request_count(self) -> int:
        """Get number of API requests made in current session"""
        return self._request_count

    def clear_cache(self):
        """Clear vulnerability cache"""
        self._cache = {}

    def get_cache_stats(self) -> Dict:
        """Get cache statistics"""
        total = len(self._cache)
        expired = 0

        for _, (_, cached_time) in self._cache.items():
            if (datetime.now(timezone.utc) - cached_time).total_seconds() >= self.CACHE_DURATION:
                expired += 1

        return {
            'total_entries': total,
            'expired_entries': expired,
            'active_entries': total - expired
        }
